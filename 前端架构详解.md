# 前端架构详解

## 整体结构对比（合约 vs 前端）





```
你的 Anchor 合约                    前端代码
─────────────────                  ─────────────────
lib.rs (指令定义)         ←→       data-access/ (调用指令)
  - create_journal_entry           - useCreateJournalEntryMutation
  - update_journal_entry           - useUpdateJournalEntryMutation  
  - delete_journal_entry           - useDeleteJournalEntryMutation

JournalEntryState (账户)   ←→       ui/ (显示数据)
  - owner                          - JournalEntryCard (卡片组件)
  - title                          - JournalEntryList (列表组件)
  - body
```

## 第一层：Anchor 导出层

### anchor/src/crudapp-exports.ts

这是**连接合约和前端的桥梁**。

typescript

```typescript
// 定义前端使用的类型（对应合约中的 JournalEntryState）
export type JournalEntryAccount = Account<JournalEntryState, string>

// 查询链上所有 Journal Entry 账户的函数
export function getJournalEntryAccounts(rpc) {
  // 通过 discriminator 过滤出所有 JournalEntryState 账户
}
```

**类比合约**：就像你在合约里定义 

JournalEntryState 结构体，这里把它导出给前端用。



## 第二层：Data Access（数据访问层）

这一层负责**调用链上程序的指令**，相当于前端版的 "指令调用器"。

### use-crudapp-accounts-query.ts - 查询数据

typescript

```typescript
export function useJournalEntriesQuery() {
  return useQuery({
    queryFn: async () => await getJournalEntryAccounts(client.rpc),
  })
}
```

**作用**：从链上读取所有 Journal Entry 账户数据。
**类比合约**：相当于用 `getProgramAccounts` 查询所有账户。

### use-crudapp-initialize-mutation.ts - 创建指令

typescript

```typescript
export function useCreateJournalEntryMutation({ account }) {
  return useMutation({
    mutationFn: async ({ title, message }) => {
      // 1. 构建指令（对应合约的 create_journal_entry）
      const instruction = await getCreateJournalEntryInstructionAsync({
        owner: signer,  // 签名者
        title,          // 标题
        message,        // 内容
      })
      // 2. 签名并发送交易
      return await signAndSend(instruction, signer)
    },
  })
}
```

**作用**：调用合约的 create_journal_entry 指令。
**流程**：构建指令 → 钱包签名 → 发送到链上



### use-crudapp-increment-mutation.ts - 更新指令

typescript

```typescript
export function useUpdateJournalEntryMutation({ account, entry }) {
  return useMutation({
    mutationFn: async ({ newMessage }) => {
      const instruction = await getUpdateJournalEntryInstructionAsync({
        owner: signer,
        title: entry.data.title,  // 用现有的 title 找到账户
        newMessage,               // 新的内容
      })
      return await signAndSend(instruction, signer)
    },
  })
}
```

**作用**：调用合约的 update_journal_entry 指令。



### use-crudapp-decrement-mutation.ts - 删除指令

typescript

```typescript
export function useDeleteJournalEntryMutation({ account, entry }) {
  return useMutation({
    mutationFn: async () => {
      const instruction = await getDeleteJournalEntryInstructionAsync({
        owner: signer,
        title: entry.data.title,
      })
      return await signAndSend(instruction, signer)
    },
  })
}
```

**作用**：调用合约的 

delete_journal_entry 指令（关闭账户）。



## 第三层：UI 组件层

这一层负责**页面展示和用户交互**。

### crudapp-ui-list.tsx - 列表组件

typescript

```typescript
export function JournalEntryList({ account }) {
  const journalEntriesQuery = useJournalEntriesQuery()  // 获取所有数据
  
  // 遍历渲染每个 JournalEntryCard
  return journalEntriesQuery.data?.map((entry) => (
    <JournalEntryCard entry={entry} />
  ))
}
```

**作用**：显示所有日志条目的列表。

### crudapp-ui-card.tsx - 卡片组件

typescript

```typescript
export function JournalEntryCard({ entry }) {
  return (
    <Card>
      <CardTitle>{entry.data.title}</CardTitle>     {/* 显示标题 */}
      <p>{entry.data.body}</p>                       {/* 显示内容 */}
      <JournalEntryButtonUpdate entry={entry} />     {/* 更新按钮 */}
      <JournalEntryButtonDelete entry={entry} />     {/* 删除按钮 */}
    </Card>
  )
}
```

**作用**：显示单个日志条目，包含更新和删除按钮。

### crudapp-ui-button-initialize.tsx - 创建按钮

typescript

```typescript
export function CreateJournalEntryButton({ account }) {
  const createMutation = useCreateJournalEntryMutation({ account })
  
  return (
    <AppModal title="Create Journal Entry">
      <Input value={title} />      {/* 输入标题 */}
      <Textarea value={message} /> {/* 输入内容 */}
      <Button onClick={() => createMutation.mutateAsync({ title, message })}>
        Create
      </Button>
    </AppModal>
  )
}
```

**作用**：弹出模态框，让用户输入标题和内容，点击创建。

### crudapp-ui-button-increment.tsx - 更新按钮

typescript

```typescript
export function JournalEntryButtonUpdate({ entry }) {
  const updateMutation = useUpdateJournalEntryMutation({ entry })
  
  return (
    <AppModal title={`Update: ${entry.data.title}`}>
      <Textarea value={newMessage} />  {/* 编辑内容 */}
      <Button onClick={() => updateMutation.mutateAsync({ newMessage })}>
        Update
      </Button>
    </AppModal>
  )
}
```

### crudapp-ui-button-decrement.tsx - 删除按钮

typescript

```typescript
export function JournalEntryButtonDelete({ entry }) {
  const deleteMutation = useDeleteJournalEntryMutation({ entry })
  
  return (
    <Button onClick={() => deleteMutation.mutateAsync()}>
      Delete
    </Button>
  )
}
```

## 数据流总结

```
用户点击 "Create" 按钮
         ↓
CreateJournalEntryButton (UI组件)
         ↓
useCreateJournalEntryMutation (Data Access)
         ↓
getCreateJournalEntryInstructionAsync (Anchor 客户端)
         ↓
钱包签名 → 发送交易
         ↓
链上执行 create_journal_entry (你的合约)
         ↓
账户创建成功
         ↓
useJournalEntriesQuery 重新查询
         ↓
JournalEntryList 更新显示
```

## 文件命名约定

| 前缀         | 含义                       |
| :----------- | :------------------------- |
| `use-*`      | React Hook（可复用的逻辑） |
| `*-mutation` | 写操作（创建/更新/删除）   |
| `*-query`    | 读操作（查询）             |
| `*-ui-*`     | UI 组件                    |

这样你就能理解为什么有这么多文件了——前端把**数据获取**、**指令调用**、**页面展示**分成了不同的层，各司其职。

## 新版 vs 旧版项目结构对比

### 旧版结构（传统 Anchor + React）



```
project/
├── app/                    # 前端（平铺的结构）
│   ├── components/
│   │   └── counter/
│   │       ├── counter-data-access.tsx   # 所有逻辑都在一个文件里
│   │       └── counter-ui.tsx
│   └── ...
├── programs/               # Anchor 合约
└── tests/
```

### 新版结构（模块化 Feature-based）

```
project/
├── anchor/                           # Anchor 合约部分
│   ├── programs/crudapp/src/         # 合约代码
│   ├── src/
│   │   ├── client/js/generated/      # Codama 自动生成的客户端
│   │   └── crudapp-exports.ts        # 导出给前端用
│   └── target/idl/                   # IDL 文件
│
├── src/                              # Next.js 前端
│   ├── app/                          # 路由页面
│   │   ├── page.tsx                  # 首页
│   │   ├── account/page.tsx          # 账户页
│   │   └── crudapp/page.tsx          # 程序页
│   │
│   ├── components/                   # 通用组件
│   │   ├── ui/                       # 基础 UI（按钮、卡片等）
│   │   └── solana/                   # Solana 相关
│   │
│   └── features/                     # ⭐ 核心：按功能模块组织
│       ├── account/                  # 账户功能模块
│       │   ├── data-access/          # 数据层
│       │   └── ui/                   # UI层
│       │
│       └── crudapp/                  # 你的程序模块
│           ├── data-access/          # 数据访问（调用合约）
│           │   ├── use-crudapp-accounts-query.ts
│           │   ├── use-crudapp-initialize-mutation.ts
│           │   └── ...
│           ├── ui/                   # UI 组件
│           │   ├── crudapp-ui-list.tsx
│           │   ├── crudapp-ui-card.tsx
│           │   └── ...
│           └── crudapp-feature.tsx   # 主页面
```

## 主要区别

| 方面           | 旧版                         | 新版                     |
| :------------- | :--------------------------- | :----------------------- |
| **前端框架**   | Create React App             | Next.js 15               |
| **代码组织**   | 按类型分（components/hooks） | 按功能模块分（features） |
| **数据访问**   | 一个大文件 `data-access.tsx` | 拆分成多个小 hooks       |
| **客户端生成** | coral-xyz/anchor 运行时      | **Codama** 编译时生成    |
| **状态管理**   | 自己写                       | TanStack Query           |
| **UI 库**      | 手写样式                     | shadcn/ui + Tailwind     |
| **钱包**       | solana/wallet-adapter        | wallet-ui/react          |

## 最大的变化：Codama 客户端

旧版：

typescript

```typescript
// 运行时解析 IDL，容易出类型问题
const program = new Program(idl, programId)
await program.methods.createJournalEntry(title, message).accounts({...}).rpc()
```

新版：

typescript

```typescript
// 编译时生成，完全类型安全
const instruction = await getCreateJournalEntryInstructionAsync({
  owner: signer,
  title,
  message,
})
await signAndSend(instruction, signer)
```

新版的优势是**完全类型安全**，IDE 自动补全更好，但代码结构更复杂，需要理解的文件更多。



## 三层封装关系



```
┌─────────────────────────────────────────────────────────────────┐
│  UI 组件 (按钮点击)                                               │
│  └── createMutation.mutateAsync({ title, message })              │
│           │                                                      │
│           ▼                                                      │
├─────────────────────────────────────────────────────────────────┤
│  data-access (业务封装)                                          │
│  └── useCreateJournalEntryMutation()                             │
│      ├── 获取钱包签名者                                           │
│      ├── 调用 SDK 构建指令                                        │
│      ├── 签名 + 发送交易                                          │
│      ├── 成功后刷新缓存                                           │
│      └── 失败时显示错误提示                                        │
│           │                                                      │
│           ▼                                                      │
├─────────────────────────────────────────────────────────────────┤
│  SDK (自动生成)                                                   │
│  └── getCreateJournalEntryInstructionAsync({ owner, title, message })  │
│      ├── 计算 PDA 地址                                            │
│      ├── 序列化指令数据                                           │
│      └── 返回 Instruction 对象                                    │
│           │                                                      │
│           ▼                                                      │
├─────────────────────────────────────────────────────────────────┤
│  链上合约                                                         │
│  └── create_journal_entry(ctx, title, message)                   │
└──────────────────────────────────────────────
```

## 每层加了什么

| 层              | 加的东西                                           |
| :-------------- | :------------------------------------------------- |
| **SDK**         | PDA 计算、序列化、类型安全                         |
| **data-access** | 钱包集成、签名发送、缓存管理、错误处理、Toast 提示 |
| **UI**          | 表单输入、按钮状态、用户交互                       |

## 好处

typescript

```typescript
// ❌ 如果没有 data-access 封装，UI 组件要写这么多：
function CreateButton() {
  const client = useSolanaClient()
  const wallet = useWallet()
  const queryClient = useQueryClient()
  
  const handleClick = async () => {
    try {
      const signer = createSigner(wallet)
      const instruction = await getCreateJournalEntryInstructionAsync({...})
      const tx = await buildTransaction(instruction)
      const signedTx = await wallet.signTransaction(tx)
      const signature = await client.sendTransaction(signedTx)
      await client.confirmTransaction(signature)
      toast.success('Created!')
      await queryClient.invalidateQueries(['crudapp', 'accounts'])
    } catch (e) {
      toast.error('Failed!')
    }
  }
}

// ✅ 有了 data-access 封装后，UI 组件只需要：
function CreateButton() {
  const mutation = useCreateJournalEntryMutation({ account })
  
  return <Button onClick={() => mutation.mutateAsync({ title, message })}>
    Create
  </Button>
}
```

**总结**：

data-access 就是把"调用合约"这个复杂操作打包成**一行代码**，UI 开发者不需要懂区块链细节，只需要知道调用什么函数、传什么参数。